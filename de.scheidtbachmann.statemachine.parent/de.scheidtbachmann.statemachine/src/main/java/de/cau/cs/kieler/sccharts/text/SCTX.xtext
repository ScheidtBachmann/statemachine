grammar de.cau.cs.kieler.sccharts.text.SCTX with de.cau.cs.kieler.kexpressions.kext.KExt

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions 
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/0.1.0" as kext
import "http://kieler.cs.cau.de/sccharts/0.3.0" as sccharts

//generate sct3 "http://kieler.cs.cau.de/sccharts/textual3/0.1.0"

// ---------------- //
//  SCCharts Rules  // 
// ---------------- //

SCCharts returns sccharts::SCCharts:
    pragmas+=Pragma*
    rootStates+=RootState*;

// ------------- //
//  State Rules  // 
// ------------- //


RootState returns sccharts::State:
	annotations+=Annotation*
	'scchart' name=ExtendedID label=STRING?
	'{'
		declarations+=DeclarationWOSemicolon*
		actions+=LocalAction*
		(regions+=ImplicitControlflowRegion | regions+=Region*)
	'}';
    

State returns sccharts::State:
	annotations+=Annotation*
	initial?='initial'?
	final?='final'?
	violation?='violation'?
	connector?='connector'?
	=>'state' name=ID label=STRING?
	((
	    'is' reference = ScopeCall
	    ('schedule' schedule+=ScheduleObjectReference+)?
	)|(
	    ('schedule' schedule+=ScheduleObjectReference+)?
	   '{'
		declarations+=DeclarationWOSemicolon*
		actions+=LocalAction*
		(regions+=ImplicitControlflowRegion | regions+=Region*)
	   '}')
	)?
	outgoingTransitions+=Transition*;
	

ImplicitState returns sccharts::State:
    {sccharts::State}
    (regions+=Region+);

	
ScopeCall returns sccharts::ScopeCall:
    scope = [sccharts::State|ID]
    (('(' parameters += ScopeParameter (',' parameters += ScopeParameter)* ')') | '(' ')')?;
    
ScopeParameter returns kexpressions::Parameter:
    ((pureOutput ?= '!')? callByReference ?= '&')?
    expression = Expression
    ('to' explicitBinding = [kexpressions::ValuedObject|ID] ('[' explicitBindingIndices+=Expression ']')*)?
    ;    
    
// ------------------ //
//  Transition Rules  // 
// ------------------ //

BoolScheduleExpression returns kexpressions::Expression:
    LogicalOrExpression
    ('schedule' schedule += ScheduleObjectReference)?;

Transition returns sccharts::Transition:
    {sccharts::Transition}
	annotations+=RestrictedTypeAnnotation*
	
	((
    	preemption=(PreemptionType | PreemptionTypeLegacy) 
        targetState=[sccharts::State|ID]
        delay=DelayType?
        deferred?='deferred'?
        history=HistoryType?
        //                      -> This alternative is only for the serializer to enable forcing of brackets
	   ('if' triggerDelay=INT? (trigger=BoolScheduleExpression | trigger=AtomicExpression) 
	       ('Pr=' triggerProbability=Double)? nondeterministic?='nondeterministic'?
	   )? 
	   ('do' effects+=Effect (';' effects+=Effect)*)?
	)
	|
	(
        delay=DelayType?
        ('if' triggerDelay=INT? (trigger=BoolScheduleExpression | trigger=AtomicExpression) 
            ('Pr=' triggerProbability=Double)? nondeterministic?='nondeterministic'?
        )?
        ('do' effects+=Effect (';' effects+=Effect)*)?
        preemption=(PreemptionType | PreemptionTypeLegacy) 
        targetState=[sccharts::State|ID]
        deferred?='deferred'?
        history=HistoryType?
	))
	
	('label' label=STRING)?;
	
// -------------- //
//  Region Rules  // 
// -------------- //

Region returns sccharts::Region:
    ControlflowRegion | DataflowRegion;

ImplicitControlflowRegion returns sccharts::ControlflowRegion:
    {sccharts::ControlflowRegion}
    states+=State+;

ControlflowRegion returns sccharts::ControlflowRegion:
    {sccharts::ControlflowRegion}
    annotations+=Annotation*
    final?='final'?
    'region' name=ExtendedID? label=STRING?
    ('for' counterVariable=CounterVariable ':' forStart=IntOrReference ('..' forEnd=IntOrReference)?)?
    ('schedule' schedule+=ScheduleObjectReference+)?
    ((
        ':'
        declarations+=DeclarationWOSemicolon*
        actions+=LocalAction*
        states+=State*
    )|(
        '{'
        declarations+=DeclarationWOSemicolon*
        actions+=LocalAction*
        (states+=ImplicitState | states+=State+)
        '}'
    ))  
    ;

    
DataflowRegion returns sccharts::DataflowRegion:
    {sccharts::DataflowRegion}
    annotations+=Annotation*
    'dataflow' name=ExtendedID? label=STRING?
    ('for' counterVariable=CounterVariable ':' forStart=IntOrReference ('..' forEnd=IntOrReference)?)? 
    ('schedule' schedule+=ScheduleObjectReference+)?
    once?='once'?
    ':'
    declarations+=DeclarationWOSemicolon*
    equations+=Assignment*;
    
    
IntOrReference returns kexpressions::Expression:
    IntValue | ValuedObjectReference;
    
    
CounterVariable returns kexpressions::ValuedObject:
    name=PrimeID;
	
// -------------- //
//  Action Rules  // 
// -------------- //
	
LocalAction returns sccharts::LocalAction:
    EntryAction | DuringAction | ExitAction | SuspendAction | PrecedingAction | SucceedingAction | PeriodAction;    

EntryAction returns sccharts::EntryAction:
	{sccharts::EntryAction}
   'entry' ('if' trigger=BoolScheduleExpression ('Pr' triggerProbability=Double)?)? ('do' effects+=Effect (';' effects+=Effect)*)?
   ('label' label=STRING)?;
         
DuringAction returns sccharts::DuringAction:
	{sccharts::DuringAction}
    delay=DelayType? 'during' ('if' triggerDelay=INT? trigger=BoolScheduleExpression ('Pr=' triggerProbability=Double)?)? ('do' effects+=Effect (';' effects+=Effect)*)?
    ('label' label=STRING)?;
         
ExitAction returns sccharts::ExitAction:
	{sccharts::ExitAction}
	'exit' ('if' trigger=BoolScheduleExpression ('Pr' triggerProbability=Double)?)? ('do' effects+=Effect (';' effects+=Effect)*)?
	('label' label=STRING)?;  
       
SuspendAction returns sccharts::SuspendAction:
	{sccharts::SuspendAction}
	delay=DelayType? weak?='weak'? 'suspend' ('if' triggerDelay=INT? trigger=BoolScheduleExpression ('Pr=' triggerProbability=Double)?)?
	('label' label=STRING)?;
      
PrecedingAction returns sccharts::PrecedingAction:
	{sccharts::PrecedingAction}
   'preceding' ('if' trigger=BoolScheduleExpression ('Pr' triggerProbability=Double)?)? ('do' effects+=Effect (';' effects+=Effect)*)?
   ('label' label=STRING)?;
         
SucceedingAction returns sccharts::SucceedingAction:
	{sccharts::SucceedingAction}
	'succeeding' ('if' trigger=BoolScheduleExpression ('Pr' triggerProbability=Double)?)? ('do' effects+=Effect (';' effects+=Effect)*)?
	('label' label=STRING)?;  

PeriodAction returns sccharts::PeriodAction:
    {sccharts::PeriodAction}
    annotations+=RestrictedTypeAnnotation*
    delay=DelayType? 'period' trigger=ValuedExpression
    ('label' label=STRING)?;
    
// ------------ //
//  Enum Rules  // 
// ------------ //

enum PreemptionType returns sccharts::PreemptionType:
	WEAKABORT = 'go to' | STRONGABORT = 'abort to' | TERMINATION = 'join to';

enum PreemptionTypeLegacy returns sccharts::PreemptionType:
    WEAKABORT = '-->' | STRONGABORT = 'o->' | TERMINATION = '>->';
    
enum DelayType returns sccharts::DelayType:
    UNDEFINED = 'undefined' | DELAYED = 'delayed' | IMMEDIATE = 'immediate' | AUTOMATIC = 'auto';    

enum HistoryType returns sccharts::HistoryType:
    RESET = 'reset' | SHALLOW = 'shallow history' | DEEP = 'history';

@Override  
enum ValueType returns kexpressions::ValueType:
    PURE="pure" | BOOL="bool" | UNSIGNED="unsigned" | 
    INT="int" | FLOAT="float" |
    STRING="string" |
    CLOCK="clock"; // als: added clock for timed automata
	
// -------------- //
//  Helper Rules  // 
// -------------- //

// These are implicit keywords due to rules such as 'go to'
HiddenKeywords: 'go' | 'abort' | 'join' | 'shallow';