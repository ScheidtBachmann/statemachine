/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.validation

import com.google.inject.Inject
import de.cau.cs.kieler.annotations.Annotation
import de.cau.cs.kieler.annotations.AnnotationsPackage
import de.cau.cs.kieler.annotations.StringPragma
import de.cau.cs.kieler.annotations.TypedStringAnnotation
import de.cau.cs.kieler.annotations.extensions.PragmaExtensions
import de.cau.cs.kieler.annotations.registry.PragmaRegistry
import de.cau.cs.kieler.kexpressions.CombineOperator
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.ReferenceCall
import de.cau.cs.kieler.kexpressions.ReferenceDeclaration
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.VectorValue
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsValuedObjectExtensions
import de.cau.cs.kieler.kexpressions.keffects.Assignment
import de.cau.cs.kieler.kexpressions.keffects.Emission
import de.cau.cs.kieler.kexpressions.keffects.extensions.KEffectsExtensions
import de.cau.cs.kieler.sccharts.Action
import de.cau.cs.kieler.sccharts.ControlflowRegion
import de.cau.cs.kieler.sccharts.DataflowRegion
import de.cau.cs.kieler.sccharts.DuringAction
import de.cau.cs.kieler.sccharts.PreemptionType
import de.cau.cs.kieler.sccharts.SCChartsPackage
import de.cau.cs.kieler.sccharts.Scope
import de.cau.cs.kieler.sccharts.ScopeCall
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.extensions.BindingType
import de.cau.cs.kieler.sccharts.extensions.SCChartsActionExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsCoreExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsFixExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsReferenceExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsStateExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsTransitionExtensions
import de.cau.cs.kieler.sccharts.text.SCTXResource
import java.util.Map
import java.util.Set
import org.eclipse.elk.core.data.LayoutMetaDataService
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.AbstractDeclarativeValidator
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SCTXValidator extends AbstractSCTXValidator {

    @Inject extension PragmaExtensions
    @Inject extension SCChartsCoreExtensions
    @Inject extension SCChartsReferenceExtensions
    @Inject extension SCChartsActionExtensions
    @Inject extension SCChartsFixExtensions
    @Inject extension SCChartsTransitionExtensions
    @Inject extension SCChartsStateExtensions
    @Inject extension KExpressionsValuedObjectExtensions
    @Inject extension KEffectsExtensions
    
    /** Service class for accessing layout options by name */
    private static final LayoutMetaDataService LAYOUT_OPTIONS_SERVICE = LayoutMetaDataService.getInstance();
    
    static val INFOS_PRAGMA = PragmaRegistry.register("infos", StringPragma, "off: Disables infos in editor.")

    static val String REGION_CANNOT_TERMINATE = "All or none concurrent regions should have final states."
    static val String REGION_NO_INITIAL_STATE = "Every region must have an initial state.";
    static val String REGION_TWO_MANY_INITIAL_STATES = "Every region must not have more than one initial state.";
    static val String REGION_NO_FINAL_STATE = "Every region should have a final state whenever its parent state has a termination transition.";
    static val String STATE_NOT_REACHABLE = "The state is not reachable.";
    static val String NO_REGION = "A state with a termination transition must have inner behaviour.";
    static val String DUPLICATE_REGION = "There are multiple regions with the same name.";
    
    static val String NON_SIGNAL_EMISSION = "Non-signals should not be used in an emission.";
    static val String NON_VARIABLE_ASSIGNMENT = "Non-variables cannot be used in an assignment.";
    static val String STATIC_VARIABLE_WITHOUT_INITIALIZATION = "Static variables should be initialized.";
    //TODO (KISEMA-1071) Remove this message when there is a transformation that handles valued signals without combine operator.
    static val String VALUED_SIGNAL_NEED_COMBINE = "Valued signals must have a combine function.";
    static val String MINMAX_COMBINE = "Min or max combine operators are currently not supported.";
    static val String NOCOMBINE = "A valued signal should have a combine function, otherwise any emits cannot be scheduled.";
    
    static val String STRONG_ABORT_WITH_LOW_PRIORITY = "Causality problem!\nStrong abort transitions must have a higher priority than weak abort or termination transitions.";
    static val String ABORT_WITHOUT_TRIGGER = "Abort transitions should have a trigger.";
    
    static val String MISSING_BINDING_FOR = "Missing binding for variable: ";

    static val String VALUEDOBJECT_TRANSITION_SCOPE_WRONG = "Variable or signal used out of its scope.\nDeclare it one hierarchy layer up!";
    
    static val String ASSIGNMENT_TO_CONST = "You cannot assign a value to a const object.";
    static val String CANNOT_BIND_ARRAYCELL_TO_ARRAY = "You cannot bind a single array cell to an array."
    static val String CANNOT_BIND_LITERAL_TO_OUTPUT = "You cannot bind a literal to an output object."
    static val String DUPLICATE_VARIABLE = "The variable is declared multiple times in this scope."
    static val String NON_IMMEDIATE_CONNECTOR = "Outgoing transitions of connector states should be marked as immediate."
    static val String NO_DEFAULT_TRANSITION = "Connector states should have an outgoing transition without trigger."
    static val String NO_OUTGOING_TRANSITION = "Connector states must have an outgoing transition."
    static val String NON_REACHABLE_TRANSITION = "The transition is not reachable."
    
    static val String IMMEDIATE_LOOP = "There is an immediate loop. The model is not SASC."
    
    static val String BROKEN_IMPORT = "Broken Import: There is no SCCharts model with the given name."
    static val String BROKEN_FOLDER_IMPORT = "Broken Import: There are no SCCharts models in the given directory."

    static val String COUNT_DELAY_OF_0 = "A count delay of 0 is not allowed on a trigger."
    
    static val String LAYOUT_ANNOTATION_ID = "Invalid layout option id.\nThere is no layout option with the given id or the given suffix is not unique.\nSee https://www.eclipse.org/elk/reference/options.html for all available layout options."
    static val String LAYOUT_ANNOTATION_VALUE = "Invalid layout option value.\nThe given value can not be parsed into a valid value for the given layout option."
    static val String LAYOUT_ANNOTATION_FORMAT = "Layout annotations must have the format '@layout[id] value'"
    
    static val String REGION_ACTION_EXPERIMENTAL = "Actions in regions are highly experimental and may not produce the expected results."    

    /**
     * Checks if given layout annotation uses an existing unique layout option id (suffix).
     */
    @Check
    def void checkRegionActions(Action action) {
        if (action.eContainer instanceof ControlflowRegion && (action.eContainer as ControlflowRegion).states.exists[final]) {
            warning(REGION_ACTION_EXPERIMENTAL, action, null);
        }
    }

    /**
     * Checks if given layout annotation uses an existing unique layout option id (suffix).
     */
    @Check
    def void checkImportPragma(Annotation anno) {
        if ("layout".equals(anno.name)) { // FIXME magic string
            if (anno instanceof TypedStringAnnotation) {
                val data = LAYOUT_OPTIONS_SERVICE.getOptionDataBySuffix(anno.type ?: "")
                if (data === null) {
                    warning(LAYOUT_ANNOTATION_ID, anno, null);
                } else {
                    if (data.parseValue(anno.values?.head ?: "".toLowerCase) === null) {
                        warning(LAYOUT_ANNOTATION_VALUE, anno, null);
                    }
                }
            } else {
                warning(LAYOUT_ANNOTATION_FORMAT, anno, null);
            }
        }
    }


    @Check
    def void checkImportPragma(StringPragma pragma) {
        if (SCTXResource.PRAGMA_IMPORT.equals(pragma.name) && pragma.eResource !== null) {
            val res = pragma.eResource as SCTXResource
            for (var i = 0; i < pragma.values.size; i++) {
                val import = pragma.values.get(i)
                if (res.directImports.get(import).empty) {
                    if (import.endsWith("*")) {
                        warning(BROKEN_FOLDER_IMPORT, pragma, AnnotationsPackage.eINSTANCE.stringPragma_Values, i);
                    } else {
                        warning(BROKEN_IMPORT, pragma, AnnotationsPackage.eINSTANCE.stringPragma_Values, i);
                    }
                }
            }
        }
    }
    
    /**
     * Check that there are no immediate loops between states in a region.
     * 
     * @param region The region 
     */
    // NORMAL Check is executed on save/build and request only
    @Check(NORMAL)
    public def void checkNoImmediateLoops(ControlflowRegion region) {
        // Perform depth first search on states,
        // where edges are the immediate transitions to find potentially immediate loops.
        val states = region.states
        // Map to remember which states have been visited already
        val Map<de.cau.cs.kieler.sccharts.State, Integer> visited = newHashMap
        for(state : states) {
            val hasLoop = findImmediateLoop(state, visited)
            if(hasLoop) {
                // Loop detected, so add warning marker on all involved states
                val Set<de.cau.cs.kieler.sccharts.State> statesWithLoop = newHashSet
                for(entry : visited.entrySet) {
                    if(entry.value == 1) {
                        statesWithLoop.add(entry.key)
                    }
                }
                val message = IMMEDIATE_LOOP + "\nInvolved states: " + statesWithLoop.map[it.name]
                for(s : statesWithLoop) {
                    // Highlight immediate transitions that lead to states, which are part of the loop.
                    // This is more helpful than highlighting the complete state.
                    for(t : s.outgoingTransitions) {
                        if(t.isImplicitlyImmediate && statesWithLoop.contains(t.targetState)) {
                            warning(message, t, null)
                        }
                    }
                }
                return;
            }
        }
    }
    
    /**
     * Helper method to find immediate loops.
     * 
     * @param state The state that is checked for loops
     * @param visited Data structure with the information whether states have been visited before.
     * @return true if a loop was detected. In this case the involved states will have a visited value of 1 in the map.
     */
    private def boolean findImmediateLoop(de.cau.cs.kieler.sccharts.State state, Map<de.cau.cs.kieler.sccharts.State, Integer> visited) {
        val visitedCode = visited.getOrDefault(state, 0)
        if(visitedCode == 2) {
            // Finished before without cycle
            return false    
        } else if(visitedCode == 1) {
            // Found cycle
            return true
        }
        // Now visited
        visited.put(state, 1)
        // Find loops in outgoing immediate transitions.
        for(t : state.outgoingTransitions) {
            // Ignore termination transitions because they could have non-immediate inner behaviour.
            val isTerminationTransition = (t.preemption == PreemptionType.TERMINATION)
            if(!isTerminationTransition && t.isImplicitlyImmediate) {
                val target = t.targetState
                // It is not checked whether or not a superstate has a delay.
                // A appropriate check should be implemented in the future. 
                if(findImmediateLoop(target, visited)) {
                    return true
                }
            }
        }
        // Now finished without cycle
        visited.put(state, 2)
        return false
    }
    
    /**
     * Discourage emissions of non-signals
     *
     * @param state the state
     */
    @Check
    def void checkNoBooleanEmissions(Emission emission) {
        if (emission.getValuedObject() !== null && emission.getValuedObject().eContainer() !== null && emission.getValuedObject().eContainer() instanceof Declaration) {
            val declaration = emission.getValuedObject().declaration
            if (declaration instanceof VariableDeclaration && !(declaration as VariableDeclaration).signal) {
                warning(NON_SIGNAL_EMISSION, emission, null, -1);
            }
        } 
    }
    
    /**
     * Region names must be unique
     *
     * @param state the State
     */
    @Check
    def void checkDuplicateRegionNames(de.cau.cs.kieler.sccharts.State state) {
        val names = <String> newHashSet
        for(r : state.regions) {
            val name = r.name
            if(!name.isNullOrEmpty) {
                if(names.contains(name)) {
                    warning(DUPLICATE_REGION+" '"+name+"'", r, AnnotationsPackage.eINSTANCE.namedObject_Name, -1)
                } else {
                    names.add(name)
                }    
            }
        }
    }

    // -------------------------------------------------------------------------    

    /**
     * Forbid assignments of non-variables
     *
     * @param state the state
     */
    @Check
    def void checkNoBooleanEmissions(Assignment assignment) {
        if (assignment.getValuedObject() !== null && assignment.getValuedObject().eContainer() !== null && assignment.getValuedObject().eContainer() instanceof Declaration) {
            val declaration = assignment.getValuedObject().declaration
            if (declaration instanceof VariableDeclaration && (declaration as VariableDeclaration).signal) {
                error(NON_VARIABLE_ASSIGNMENT, assignment, null, -1);
            }
        } 
    }

    // -------------------------------------------------------------------------

    /**
     * A state should be reachable from an initial state.
     *
     * @param state the state
     */
    @Check
    def void checkReachableStates(de.cau.cs.kieler.sccharts.State state) {
        if (!state.isStateReachable) {
           warning(STATE_NOT_REACHABLE, state, null, -1);
        }
    }
        
    /**
     * Check that there are no transitions that are not reachable, i.e.,
     * no transitions after a transition without guard.
     * 
     * @param state The state 
     */
    @Check
    public def void checkTransitionsAreReachable(de.cau.cs.kieler.sccharts.State state) {
        var boolean delayedTransitionWithoutTrigger = false
        var boolean immediateTransitionWithoutTrigger = false
        for(trans : state.outgoingTransitions) {
            if(trans.isImplicitlyImmediate) { 
                // An immediate transition may follow after a delayed transition without trigger, and still be reachable.
                if(immediateTransitionWithoutTrigger) {
                    warning(NON_REACHABLE_TRANSITION, trans, null)
                }
                if(!immediateTransitionWithoutTrigger && trans.trigger === null) {
                    // A termination transition does not count, because the inner behavior defines a trigger
                    if(!trans.isTermination) {
                        immediateTransitionWithoutTrigger = true    
                    }
                }
            } else {
                // An delayed transition after a delayed transition without trigger is not reachable.
                // Neither is a delayed transition after an immediate transition without trigger.
                if(delayedTransitionWithoutTrigger || immediateTransitionWithoutTrigger) {
                    warning(NON_REACHABLE_TRANSITION, trans, null)
                }
                if(!delayedTransitionWithoutTrigger && trans.trigger === null) {
                    delayedTransitionWithoutTrigger = true
                }
            }
        }
    }

    /**
     * Check that connector states have only immediate transitions and have a default transition.
     * 
     * @param state The state 
     */
    @Check
    public def void checkConnectorTransitions(de.cau.cs.kieler.sccharts.State state) {
        if(state.connector) {
            var Transition lastTransition
            var boolean transitionWithoutTrigger = false
            for(trans : state.outgoingTransitions) {
                if(!trans.isImmediate) {
                    warning(NON_IMMEDIATE_CONNECTOR, trans, null)
                }
                if(trans.trigger === null) {
                    transitionWithoutTrigger = true
                }
                lastTransition = trans
            }
            if(!transitionWithoutTrigger) {
                warning(NO_DEFAULT_TRANSITION, lastTransition, null)
            }
            if(lastTransition === null) {
                error(NO_OUTGOING_TRANSITION, state, null)
            }
        }
    }

    /**
     * Check that names of variables are unique within a scope.
     * 
     * @param scope The scope 
     */
    @Check
    public def void checkDuplicateVariable(Scope scope) {
        val Set<String> variableNames = newHashSet()
        for(decl : scope.declarations) { 
            for(valuedObject : decl.valuedObjects) {
                val name = valuedObject.name
                if(variableNames.contains(name)) {
                    warning(DUPLICATE_VARIABLE, valuedObject, null)
                } else {
                    variableNames.add(name)
                }
            }
        }
    }

    /**
     * Check if valued signal has a combine functions
     *
     * @param valuedObject the valuedObject
     */
    @Check
    public def void checkCombineFunction(ValuedObject valuedObject) {
        // Check if actually a valued signal
        if(valuedObject.isSignal && !valuedObject.isPureSignal) {
            // Check if there is a combine operator
            if(valuedObject.combineOperator === null) {
                warning(NOCOMBINE, valuedObject, null)
            }
        }
    } 


    /**
     * Check if max or min is used which is currently not supported
     *
     * @param valuedObject the valuedObject
     */
    @Check
    public def void checkMinMaxUsedCombinationFunction(ValuedObject valuedObject) {
        // Check if actually a valued signal
        if(valuedObject.isSignal && !valuedObject.isPureSignal) {
            // Check if there is a combine operator
            if(valuedObject.combineOperator !== null) {
                if (valuedObject.combineOperator.equals(CombineOperator.MIN) || valuedObject.combineOperator.equals(CombineOperator.MAX))
                warning(MINMAX_COMBINE, valuedObject, null)
            }
        }
    } 
    
    /**
     * Check if there is exactly ONE initial state per region.
     *
     * @param region the region
     */
    @Check
    public def void checkInitialState(ControlflowRegion region) {
        // Do not consider the root region == SCChart
        if (region.getParentState() !== null) {
            // check if parent state has declared any REAL region not only a
            // dummy region for entry/during/exit actions or suspends
            val parentState = region.getParentState
            var int foundInitial = 0;
            if ((parentState.actions.size() > 0) && (parentState.getRegions().size() == 1)
                    && parentState.getRegions().filter(typeof(ControlflowRegion)).head.getStates().size() == 0
                    && (parentState.getRegions().head.name === null
                        || parentState.getRegions().head.name.equals(""))) {
                foundInitial = 1;
            }
            for (de.cau.cs.kieler.sccharts.State state : region.getStates()) {
                if (state.isInitial()) {
                    foundInitial = foundInitial + 1;
                }
            }
            if (foundInitial == 0) {
                error(REGION_NO_INITIAL_STATE, region, null, -1);
            } else if (foundInitial > 1) {
                error(REGION_TWO_MANY_INITIAL_STATES, region, null, -1);
            }
        }
    }
    
    /**
     * A final state only makes sense if all regions can terminate.
     * Thus if there is one final state, the other regions should also have final states.
     * 
     * @param state the state
     */
    @Check
    public def void checkAllHaveFinalStates(ControlflowRegion region) {
        val finalStates = region.states.filter[it.isFinal]
        if(!finalStates.isNullOrEmpty) {
            for(r : region.parentState.regions.filter(ControlflowRegion)) {
                // Only check other regions
                if(r !== region) {
                    val otherHasFinalState = r.states.exists[it.isFinal]
                    // Warn if this region cannot terminate
                    if(!otherHasFinalState) {
                        for(finalState : finalStates) {
                            warning(REGION_CANNOT_TERMINATE, finalState, AnnotationsPackage.eINSTANCE.namedObject_Name);
                        }
                    }
                }
            }
        }
    }
    
    /**
     * A state with a termination transition should have final states in all its
     * inner regions. 
     * A simple state with a termination transition must have inner behaviour or no termination transition at all.
     * 
     * @param state the state
     */
    @Check
    public def void checkFinalStates(de.cau.cs.kieler.sccharts.State state) {
        // Check if state has termination transition
        val terminationTransitions = state.outgoingTransitions.filter[ isTermination ]
        val foundTermination = !terminationTransitions.empty
        if (foundTermination) {
            // Assert inner behaviour
            val regions = state.regions.filter(ControlflowRegion)
            if(regions.isEmpty && state.reference === null) {
                val trans = terminationTransitions.get(0)
                error(NO_REGION, trans, null, -1);
            }

            // Now test for every region
            if (state.actions.nullOrEmpty) {
                for (region : regions) {
                    val foundFinal = !region.states.filter[ isFinal ].empty
                    if (!foundFinal) {
                        warning(REGION_NO_FINAL_STATE, region, AnnotationsPackage.eINSTANCE.namedObject_Name, -1);
                    }
                }
            }
        }
    }
    
    /**
     * Checks that no superfluous count delays are used.
     */
    @Check
    public def void checkCountDelayGreaterThan1(Transition transition) {
        if(transition.triggerDelay == 0) {
            error(COUNT_DELAY_OF_0, transition.trigger, null)
        }
    }
    
    /**
     * Checks if the given state has any strong abort transitions with lower priority than non-strong-abort transitions-
     */
    @Check
    public def void checkLowPriorityStrongAbort(de.cau.cs.kieler.sccharts.State state) {
        var onlyStrongAbortsBefore = true;
        // Checking priority by order
        for (transition : state.outgoingTransitions) {
            if (onlyStrongAbortsBefore && !transition.isStrongAbort) {
                onlyStrongAbortsBefore = false;
            } else if (!onlyStrongAbortsBefore && transition.isStrongAbort) {
                error(STRONG_ABORT_WITH_LOW_PRIORITY, transition, null, -1);
            }
        }
    } 

    /**
     * Checks if the given state has abort transitions without trigger and adds a warning.
     * In most cases an abort without trigger is meant to be a termination transition.
     */
    @Check
    public def void checkAbortHasTrigger(de.cau.cs.kieler.sccharts.State state) {
        if(state.isHierarchical) {
            for (transition : state.outgoingTransitions) {
                if ((transition.isStrongAbort || transition.isWeakAbort)
                    && transition.trigger === null) {
                    warning(ABORT_WITHOUT_TRIGGER, transition, null, -1);
                }
            }
        }
    } 
    
    /**
     * Checks if the given valued signal has a combination function.
     * This check can be removed if there is a transformation
     * that handles valued signals without combination dfunction (see KISEMA-1071).   
     */
    // TODO: (KISEMA-1071) Remove this check when there is a transformation that handles valued signals without combination function.
    @Check
    public def void checkValuedSignalHasCombinationFunction(ValuedObject valuedObject) {
        // Check if actually a valued signal
        if(valuedObject.isSignal && !valuedObject.isPureSignal) {
            // Check if there is a combine operator
            if(valuedObject.combineOperator === null || valuedObject.combineOperator.equals(CombineOperator.NONE)) {
                warning(VALUED_SIGNAL_NEED_COMBINE, valuedObject, null)
            }
        }
    } 
    
    /**
     * Checks that static variables are initialized.
     * If it is not initialized the static modifier is useless from a modeling perspective.   
     */
    @Check
    public def void checkStaticVariableIsInitialized(ValuedObject valuedObject) {
        if(valuedObject.isStatic && valuedObject.initialValue === null) {
            warning(STATIC_VARIABLE_WITHOUT_INITIALIZATION, valuedObject, null)
        }
    } 
    
    /**
     * Checks scope of valued objects of transition triggers are correct.
     */
    @Check
    public def void checkScopeOfOutgoingTransitionVarRefs(ValuedObject testValuedObject) {
        val stateOrRegion = testValuedObject.eContainer.eContainer
        var de.cau.cs.kieler.sccharts.State state
        if (stateOrRegion instanceof AbstractDeclarativeValidator.State) {
            state = (stateOrRegion as de.cau.cs.kieler.sccharts.State)
        } else if (stateOrRegion instanceof ControlflowRegion) {
            val region = (stateOrRegion as ControlflowRegion)
            state = region.parentState
        } else {
            return
        }
        
        for (transition : state.outgoingTransitions) {
            val valuedObjectRefs = transition.eAllContents.filter(typeof(ValuedObjectReference))
            if (valuedObjectRefs.filter[valuedObject == testValuedObject].size > 0) {
                error(VALUEDOBJECT_TRANSITION_SCOPE_WRONG, testValuedObject, null, -1);
            }
        }
    }
    
    /**
     *
     * @param state the state
     */
    @Check
    def void checkAssignmentToConst(Assignment assignment) {
        if (assignment.getValuedObject() !== null) {
            val declaration =  assignment.getValuedObject.variableDeclaration
            if (declaration !== null && declaration.isConst()) {
                error(ASSIGNMENT_TO_CONST, assignment, null, -1);
            }
        }
    }    
    
    @Check
    def void checkScopeCall(ScopeCall scopeCall) {
        if (scopeCall.eContainer instanceof Scope) {
            val bindings = scopeCall.eContainer.asScope.createBindings
            var errorMessage = ""
            var implicitMessage = ""
            for (binding : bindings) {
                if (binding.errors > 0) {
                    errorMessage = binding.errorMessages.join("\n")
                }
                if (binding.type == BindingType.IMPLICIT) {
                    implicitMessage += binding.targetValuedObject.name + ", "
                    implicitMessage.replaceFirst(", $", "")
                }
            }
            
            if (errorMessage != "") {
                error("The referencing binding is erroneous!\n" + errorMessage,
                    scopeCall, 
                    SCChartsPackage.eINSTANCE.scopeCall_Scope, 
                    "The referencing binding is erroneous!\n" + errorMessage);
            } else if (implicitMessage != "") {
                warning("Valued Objects are bound implicitly!\n" + implicitMessage,
                    scopeCall, 
                    SCChartsPackage.eINSTANCE.scopeCall_Scope, 
                    "Valued Objects are bound implicitly!\n" + implicitMessage);
            }
        }
    }
    
    @Check
    def void checkReferencingStateFinalState(de.cau.cs.kieler.sccharts.State state) {
        if (state.reference === null) return;
        if (state.reference.scope === null) return;
        if (state.terminationTransitions.empty) return;
            
        if (!state.reference.scope.asState.mayTerminate) {
            warning("The referenced SCChart does not terminate, but you are using a termination to proceed.",
                state.reference,
                SCChartsPackage.eINSTANCE.scopeCall_Scope);
        }            
    }
    
    @Check
    def void checkActionTriggerEffectsWithLabel(Action action) {
        if (!action.label.nullOrEmpty) {
            if (action.trigger !== null) {
                if (infosEnabled(action))
                    info("The trigger of this action is hidden by the label.", 
                        action, 
                        SCChartsPackage.eINSTANCE.action_Trigger)
            }
            if (action.effects !== null && action.effects.size > 0) {
                if (infosEnabled(action))
                    info("The effects of this action are hidden by the label.", 
                        action, 
                        SCChartsPackage.eINSTANCE.action_Effects)
            }
        }
    }
    
    @Check
    def void checkCountDelayOnDuringAction(DuringAction action) {
        if (action.triggerDelay > 1) {
            warning("Count Delays on During Actions are not supported yet. The valued will be ignored by the transformation.",
                action, SCChartsPackage.eINSTANCE.action_TriggerDelay);
        }
    }
    
// chsch: deactivated as 'For' requires the full KiCool infrastructure 
//    @Check
//    def void checkForRegion(ControlflowRegion region) {
//        if (region.forStart !== null && region.forStart instanceof ValuedObjectReference) {
//            val forRange = For.getForRegionRange(region)
//            if (forRange.second == -1) {
//                error("The range of the counter variable of the for region is not determinable. The array cardinalities of you array must be an int or a const int.",
//                    region, SCChartsPackage.eINSTANCE.state_Regions
//                )
//            }
//        }
//    }
    
    @Check(CheckType.NORMAL)
    def void checkDataflowVectorAssignment(DataflowRegion dataflowRegion) {
        for(equation : dataflowRegion.equations) {
            val reference = equation.reference
            if (reference instanceof ValuedObjectReference) {
                if (reference.valuedObject.declaration instanceof ReferenceDeclaration) {
                    if (reference.subReference === null && !(equation.expression instanceof VectorValue)) {
                        error("You are assigning a scalar value to a reference. You should specify the input variable of the reference or use a vector value instead of a scalar.",
                            equation, null)
                    }
                }
            }
        }
    }
    
    @Check(CheckType.NORMAL)
    def void checkCorrectExternalReferenceObjects(ValuedObjectReference valuedObjectReference) {
        val valuedObject = valuedObjectReference.valuedObject
        if (valuedObject.isExternalReference) {
            if (!(valuedObjectReference instanceof ReferenceCall)) {
                warning("You are using an external reference without call syntax. If you want to generate a call, you must add parentheses.", 
                    valuedObjectReference, null)
            }
        }
    }
    
    @Check(CheckType.NORMAL) 
    def void checkFloatingPointTriggerComparison(Action action) {
        if (action.trigger !== null) {
            val trigger = action.trigger
            if (trigger instanceof ValuedObjectReference) {
                if (trigger.valuedObject.isFloat) {
                    error("Float tests must have a comparison operator!", 
                        action.trigger, null)
                }
            }
        }
    }
        
    // ENFORCER SPECIFIC
    
    public static val DIRECTOR = "director"
    public static val ENFORCER = "Enforcer"
    
    public static val CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR = 
        "Violation states require enforcer director" 
        
    @Check
    def void checkViolationState(de.cau.cs.kieler.sccharts.State state) {
        if (state.violation) {
            val scc = state.getSCCharts
            if (!scc.getStringPragmas(DIRECTOR).last.values.head.equals(ENFORCER)) {
                error(CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR, state, 
                    SCChartsPackage.eINSTANCE.state_Violation, CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR
                )
            }
        }
    }
    
    
    private def boolean infosEnabled(EObject eObject) {
        val scc = eObject.getSCCharts
        val infoPragma = scc.getStringPragmas(INFOS_PRAGMA).head
        if (infoPragma !== null && infoPragma.values.size > 0 && infoPragma.values.head.equals("off")) {
            return false
        }
        return true
    }
    
    
}
